## 04장 변수

### 변수를 사용하는 이유
> `10+20` 코드의 경우 메모리의 임의의 위치에 `10`, `20`, `30` 이 저장 (물론 이진수로~)
> 메모리에는 성공적으로 저장되었지만 `30`을 재사용하기 위해서는?

__메모리 주소를 통해 연산 결과에 접근한다면?__
- 메모리 주소를 통해 직접 접근하는 것은 치명적인 오류를 발생시킬 수 있는 위험한 일
- 실수로 운영체제가 사용하고 있는 값을 변경하면 치명적인 오류 발생 가능
- 이런 이유로 자바스크립트는 개발자의 직접적인 메모리 제어를 허용하지 않음
- 자바스크립트가 직접적인 메모리 제어를 허용해도 코드 실행 시 상황에 따라 메모리 주소는 매번 변경됨
- 코드가 실행되기 전에는 메모리 주소를 알 수 없고 알려주지도 않음


#### 💡 그래서 메모리 공간을 식별하기 위한 변수가 존재하는 것

#
### var

#### var의 단점
- 블록 레벨 스코프 지원하지 않음
- 함수 레벨 스코프 지원
- 의도하지 않은 전역 변수 선언으로 심각한 부작용 발생 가능

> 메모리 공간에 쓰레기 값이 남아있어도 var는 암묵적으로 초기화를 수행해 쓰레기 값이 나오지 않음 -> `undefined가 나올 뿐 ^ㅠ^`

> var, let, const 차이  
> https://gist.github.com/LeoHeo/7c2a2a6dbcf80becaaa1e61e90091e5d

#
### 실행 컨텍스트 (excution context)
- 변수 이름을 비롯한 모든 식별자는 실행 컨텍스트에 등록
- 자바스크립트 엔진이 소스코드를 평가하고 실행하기 위해 필요한 환경을 제공하고 코드의 실행 결과를 관리하는 영역

#
### 변수 선언의 실행 시점과 변수 호이스팅
- 자바스크립트 코드는 인터프리터에 의해 한 줄씩 순차적으로 실행
- 하지만 변수의 선언은 `런타임이 아닌 소스코드의 평가 과정` 에서 진행
- 코드를 실행하기 전 소스코드 평가 단계에서 자바스크립트 엔진은 변수 선언을 포함한 모든 선언문(변수 선언문, 함수 선언문)을 소스코드에서 찾아내 실행

#### 💡 호이스팅
변수 선언문이 코드의 선두로 끌러 올려진 것처럼 동작하는 자바스크립트 고유의 특징으로 변수 호이스팅(variable hoisting)이라고 함


> 변수 선언과 할당의 실행 시점도 다르다
```js
console.log(score); // undefined

var score; // 변수 선언
score = 80 // 값의 할당

console.log(score)  //80
```
- 변수 선언은 런타임 이전에 미리 실행되지만 값의 할당은 런타임에 진행

> 하지만 변수에 값을 할당할 때는 이전 값 undefined가 저장되어 있던 메모리 공간을 지우고 새롭게 저장하는 것이 아니라, 새로운 메모리 공간을 확보하고 저장한다는 점 주의하기!!
<img width="959" alt="image" src="https://user-images.githubusercontent.com/59560592/215325896-df603325-29fc-4f2c-884a-8e996e9eef2a.png">


# 
### 값의 재할당
이미 값이 할당되어 있는 변수에 새로운 값을 또다시 할당

- var는 재할당 가능, 엄밀히 말하면 처음으로 할당되는 값도 재할당 (위의 이미지 참고)
- 값을 재할당할 수 없다면 변수가 아닌 상수
- 값이 재할당 될 때마다 메모리 공간을 새로 확보
- 불필요한 값들은 가비지 콜렉터에 의해 메모리에서 자동 해제 (언제 해제되는지는 예측 불가)

#
### 언매니지드 언어(unmanaged language) / 매니지드 언어 (managed language) 
프로그래밍 언어는 메모리 관리 방식에 따라 언매니지드 언어와 매니지드 언어로 분류할 수 있다.

#### 💡 언매니지드 언어(unmanaged language)
- C언어와 같은 언어로 개발자가 명시적으로 메모리를 할당하고 해제
- malloc()과 free()와 같은 저수준 메모리 제어 기능 제공
- 개발자의 역량에 따라 최적의 선능을 확보할 수 있으나, 치명적 오류를 생산할 수도 있음

#### 💡 매니지드 언어 (managed language)
- 자바스크립트 같은 언어로 메모리의 할당 및 해제를 위한 메모리 관리 기능을 언어 차원에서 담당
- 개발자의 직접적인 메모리 제어를 허용하지 않아 개발자가 메모리를 할당하고 해제할 수 없음
- 메모리 관리는 가비지 콜렉터가 수행하며 이 또한 개발자가 관여 불가
- 개발자의 역량에 의존하는 부분이 상대적으로 작아져 일정한 생산성을 확보 가능하지만, 성능 면에서 손실 감수 필요
